[핵심 아이디어]
테트리스의 기본적인 규칙은 다음과 같다.
1. 현재 떨어지는 블록이 없을 경우 블록이 1개 생성되며 생성된 블록은 일정시간마다 1칸씩 아래로 떨어진다.
2. 떨어지는 블록은 상단 방향키를 통해 회전시킬 수 있으며 좌우 방향키로 이동, 하단 방향키로 1칸 하락, 스페이스바를 눌러 즉시 떨어트릴 수 있다.
3. 블록이 바닥 또는 이미 놓여있는 블록에 떨어질 경우 블록은 고정되고, 다른 블록이 생성된다.
4. 가로줄이 모두 블록으로 가득 찬 경우 그 가로줄은 제거되고, 점수를 얻는다.
5. 보드판의 크기는 가로 10, 세로 20이다.
6. 블록이 내려오는 속도는 시간이 지날수록 빨라진다.
 
<기본 셋팅>
1. 보드 판
 1.1. 보드크기 : 10 * 20
 1.2. 실제 보드 배열의 크기
  1.2.1. row : 25 (0~23) (0은 보이지 않기에 빈공간, 1~2는 블록이 생성되기 위한 빈 공간, 3~22는 실제 보드, 23은 바닥)
  1.2.2. column : 12 (0~11) (0은 왼쪽 벽, 1~10은 실제 보드, 11은 오른쪽 벽)
 1.3. 보드 좌표
   x좌표 : 0~4 : hold를 위한 공간 / 5 : 왼쪽 벽 / 6~15 : 보드 / 16 : 오른쪽 벽 / 17~21 : next를 위한 공간
   y좌표 : 0 : 빈공간 / 1~2 : 블록이 생성되는 공간 / 3~22 : 실제 보드 및 next, hold가 존재하는 공간 / 23 : 바닥
 
2. 블록 배열 (시계방향 회전순서) (모든 블록은 [1][1]을 중심 좌표로 한다.)(4*4배열에 저장한다. 3*3으로 표시하여 4*4에 비해 부족한 부분들은 전부 0으로 채운다.)
 2.1. Z미노 (빨간색) (코드 1)
 	1 2 0	0 0 1	0 0 0	0 4 0
	0 3 4	0 3 2	4 3 0	2 3 0
	0 0 0	0 4 0	0 2 1	1 0 0
 2.2. L미노 (주황색) (코드 2)
	0 0 4	0 1 0	0 0 0	4 3 0
	1 2 3	0 2 0	3 2 1	0 2 0
	0 0 0	0 3 4	4 0 0	0 1 0
 2.3. O미노 (노란색) (코드 3)
	0 1 4	나머지 모두 같다.
	0 2 3
	0 0 0
 2.4. S미노 (초록색) (코드 4)
	0 2 1	0 4 0	0 0 0	1 0 0
	4 3 0	0 3 2	0 3 4	2 3 0
	0 0 0	0 0 1	1 2 0	0 4 0
 2.5. J미노 (파란색) (코드 5)
	4 0 0	0 3 4	0 0 0	0 1 0
	3 2 1	0 2 0	1 2 3	0 2 0
	0 0 0	0 1 0	0 0 4	4 3 0
 2.6. T미노 (보라색) (코드 6)
	0 4 0	0 3 0	0 0 0	0 1 0
	3 2 1	0 2 4	1 2 3	4 2 0
	0 0 0	0 1 0	0 4 0	0 3 0
 2.7. I미노 (하늘색) (코드 7)
	0 0 0 0	0 0 1 0	0 0 0 0	0 4 0 0
	1 2 3 4	0 0 2 0	0 0 0 0	0 3 0 0
	0 0 0 0	0 0 3 0	4 3 2 1	0 2 0 0
	0 0 0 0	0 0 4 0	0 0 0 0	0 1 0 0
 
<블록 생성 및 하락>
1. 블록생성
 1.1. 현재 활성화 된 블록이 없을 경우 즉, 현재 플레이어 조작중인 블록이 없을 경우 보드 중앙 상단에 블록이 생성된다.
 1.2. 블록의 생성 위치는 블록의 블록의 중앙 (즉, 3x3 배열의 [1][1])이 상하로 22번째 칸, 왼쪽에서 5번째칸([1][5])이 오게 생성된다.
      (단, I미노 블록은 왼쪽에서 4, 5, 6, 7번째에 형성된다.) (실제 게임에서 보이는 보드는 10*20이지만 프로그램 안에선 더 크게 잡는다.)
 1.3. 7bag를 통해 최대 13번 안에 같은 블록이 2번이상 나오도록 한다.
 1.4. next를 위해 미리 7bag에서 블록을 뽑아놔 next블록 5개를 정해두고, next에 있는 블록을 생성하도록 한다.
 1.5. hold를 사용하여 hold안에 있는 블록을 소환할 때는 next에 있는 블록을 소진하지 않도록 한다.
 
2.블록 낙하
 2.1. 블록이 생성되면 블록의 좌표를 배열에 따로 저장한다.
 2.2. 일정 시간이 지나면 저장된 블록의 좌표들을 +1 시킨다.
  2.2.1. 일정 시간은 시간함수를 이용한다.
 2.3. 단, 저장된 블록 좌표 바로 밑이 0이 아닐 경우, 낙하는 종료되고 새로운 블록을 형성한다.
 
<키보드 입력을 통한 회전 제어>
1. 키보드 입력
 1.1. 프로그램을 while문으로 계속 돌려 게임이 계속 진행되게 함과 동시에 kbhit()함수가 1이 될때 conio.h에 있는 getch를 이용하여 입력을 받는다.
2. 키셋팅
 2.1. <, > : 현재 블록을 좌우로 움직이기
 2.2. spacebar : 하드드롭 (바로 떨어트리기)
 2.3. z, ctrl : 반시계 (왼쪽 회전)
 2.4. x, ↑ : 시계 (오른쪽 회전)
 2.5.↓ : 소프트드롭 (아래로 한칸)
3. 회전 제어
 3.1. 회전과 관련된 키 입력을 받았을 때, 실행하게 된다.
 3.2. 회전을 하면 회전 인덱스 값을 변화시켜서 블록들의 좌표가 다시 업데이트 되도록 한다. 
      이 때 z회전은 인덱스가 감소하는 방향, x회전은 인덱스가 증가하는 방향으로 한다.
 3.3. 회전을 하기 전에, 미리 해당좌표에 블록 혹은 벽이 있는지 확인해야 한다.
 
<실시간 화면 출력>
1. 기본 화면

□□hold□□                          □□next□□
□    ■    □                          □	       □
□ ■■■  □                          □	       □
□□□□□□                          □---------□
	 □                          □	       □
             □                          □	       □
             □                          □---------□
             □                          □	       □
             □                          □	       □
             □                          □---------□
             □                          □	       □
             □                          □	       □
             □                          □---------□
             □                          □	       □
             □                          □	       □
             □                          □□□□□□
             □                          □
             □                          □
             □                          □
             □                          □
             □		      □
             □□□□□□□□□□□□
2. 화면의 변화
 2.1. 블록을 출력하는 경우에는 goto_xy를 통해 커서를 움직인 후 (사각형의 사이즈가 2이므로 x좌표는 2배를 한다.)
      블록 코드에 맞는 블록을 출력하도록 한다.
 2.2. 블록을 한번에 움직이게 하기 위해 미리 블록이 움직이도록 시뮬레이션 한 뒤, 최종 모양을 출력하는 형태로 한다.

<보드판 관리>

[세부 함수 내용]
-메인함수-
1.settingBoard()를 실행한다.
2.while(1)을 통해 다음을 반복한다.
 2.1. playing = updateGame()을 실행한다.
 2.2. playing = 0인 경우 반복을 종료한다.

-int updateGame()-
1. createBlock()를 실행한다.
2. fallingBlock()를 실행한다.
last. return 0;

-void settingBoard-
1. board[0, 21][0~11] / board[0~21][0, 11]의 값을 -1로 설정한다.
2. board[0~21][0~11]까지 printBoard(board[row][column])을 통해 출력한다.
3. settingBlock()
4. gameStartTime = clock(), criteriaTime = clock();

-void printBoard(int blockCode, int x, int y)-
1.사각형의 크기가 2*1사이즈이므로 x*=2를 한다.
2.goto_xy(x, y)
3. blockCode 값에 따라 다음과 같이 출력한다.
 1.1. -1인 경우 □ 출력
 1.2. 0인 경우 "  " 출력 (빈칸 2칸)
 1.3. 나머지 경우 ■ 출력
 
-void goto_xy(int x, int y)-
1. HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE) 선언
2. COORD pos 선언(커서 위치)
3. pos.X = x / pos.Y = y (커서 위치 설정)
4. SetConsoleCursorPosition(handle, pos) (커서 위치 지정)

-void createBlock()-
0. blockExistence가 1인 경우 return 한다.
1. blockCode를 1~7사이의 무작위 정수로 설정한다.
2. blockCode에 따라 board값을 수정한다.
 2.1. board[0][4]~board[3][7]까지 수정해준다.
 2.2. 수정할 때마다 해당 블록값이 0이 아닌 경우 printBoard(blockCode, x, y)를 통해 출력 또한 수정해준다.
 2.3. blockQueue[remainBlock]의 x, y, code값도 수정해준다.

-void settingBlock()-
모든 미노의 블록 모양을 설정한다. (2번 항목 참고)

-void fallingBlock()-
0. blockExistence가 0인 경우 return 한다.
1. nowTime = clock();
2. nowTime - criteriaTime >= delayTime인 경우
 2.1. criteriaTime = clock();
 2.2. delayTime -= 5;
 2.3. softDrop();

-void softDrop()-
1. temp = blockMoveSimulation(blockQueue, 0, 1)
2. 만약 temp == 0인 경우
 2.1. i = 0~3 반복
  2.1.1. inputPreloadBlockQueue(i, blockQueue[i].code + 7, blockQueue[i].x, blockQueue[i].y)
 2.2. reloadBlock()
 2.3. blockExistence = 0;
3. temp == 1인 경우 reloadBlock()

-int blockMoveSimulation(block blockQueue[4], int moveX, int moveY)
1. moveX값에 따라 다음을 실행한다.
 1.1. moveX값이 0인 경우 다음 과정으로 넘어간다.
 1.2. moveX값이 0이 아닌 경우
  1.2.1. i = 0~3 으로 반복한다.
  1.2.2. board[blockQueue[i].x + moveX][y]값을 확인한다.
   1.2.2.1. 값이 0 혹은 blockQueue[i].code인 경우 다음 과정으로 넘어간다.
   1.2.2.2. 그렇지 않은 경우 return 0을 해준다.
  1.2.3. inputPreloadBlockQueue(i, blockQueue[i].code, blockQueue[i].x + moveX, blockQueue[i].y)
2. moveY값에 따라 1번 과정과 같은 과정을 y좌표를 대상으로 실행한다.
3. return 1;

-void inputPreloadBlockQueue(int index, int code, int x, int y)
1. preloadBlockQueue[index]에 code, x, y값을 저장해준다.

-void reloadBlock()
1. i = 0~3으로 반복해준다.
2. board[blockQueue[i].x][blockQueue[i].y] = 0
3. printBoard(0, blockQueue.x, blockQueue.y);
4. 다시 i = 0~3으로 반복해준다.
5. board[preloadBlockQueue[i].x][preloadBlockQueue[i].y] = preloadBlockQueue[i].code;
6. blockQueue[i] = preloadBlockQueue[i]
7. printBoard(blockQueue.code, blockQueue.x, blockQueue.y);
 

