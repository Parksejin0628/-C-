[핵심 아이디어]
테트리스의 기본적인 규칙은 다음과 같다.
1. 현재 떨어지는 블록이 없을 경우 블록이 1개 생성되며 생성된 블록은 일정시간마다 1칸씩 아래로 떨어진다.
2. 떨어지는 블록은 상단 방향키를 통해 회전시킬 수 있으며 좌우 방향키로 이동, 하단 방향키로 1칸 하락, 스페이스바를 눌러 즉시 떨어트릴 수 있다.
3. 블록이 바닥 또는 이미 놓여있는 블록에 떨어질 경우 블록은 고정되고, 다른 블록이 생성된다.
4. 가로줄이 모두 블록으로 가득 찬 경우 그 가로줄은 제거되고, 점수를 얻는다.
5. 보드판의 크기는 가로 10, 세로 20이다.
6. 블록이 내려오는 속도는 시간이 지날수록 빨라진다.
 
테트리스 개발에서 크게 고려해야 할 알고리즘은 다음과 같다.
 
<기본 셋팅>
1. 보드 판
 1.1. 보드크기 : 10 * 20
 1.2. 실제 보드 배열의 크기
  1.2.1. row : 24 (0~23)
  1.2.2. column : 12 (0~11)
 1.3. 보드의 벽 : [23][0~11] / [0~23][0, 11]
 1.4. 블록 생성 좌표 : [1][5]
 
2. 블록 배열 (시계방향 회전순서) (모든 블록은 [1][1]을 중심 좌표로 한다.)(4*4배열에 저장한다. 3*3으로 표시하여 4*4에 비해 부족한 부분들은 전부 0으로 채운다.)
 2.1. Z미노 (빨간색)
 	1 1 0	0 0 1	0 0 0	0 1 0
	0 1 1	0 1 1	1 1 0	1 1 0
	0 0 0	0 1 0	0 1 1	1 0 0
 2.2. L미노 (주황색)
	0 0 2	0 2 0	0 0 0	2 2 0
	2 2 2	0 2 0	2 2 2	0 2 0
	0 0 0	0 2 2	2 0 0	0 2 0
 2.3. O미노 (노란색)
	0 3 3	나머지 모두 같다.
	0 3 3
	0 0 0
 2.4. S미노 (초록색)
	0 4 4	4 0 0	0 0 0	4 0 0
	4 4 0	4 4 0	0 4 4	4 4 0
	0 0 0	0 4 0	4 4 0	0 4 0
 2.5. J미노 (파란색)
	5 0 0	0 5 5	0 0 0	0 5 0
	5 5 5	0 5 0	5 5 5	0 5 0
	0 0 0	0 5 0	0 0 5	5 5 0
 2.6. T미노 (보라색)
	0 6 0	0 6 0	0 0 0	0 6 0
	6 6 6	0 6 6	6 6 6	6 6 0
	0 0 0	0 6 0	0 6 0	0 6 0
 2.7. I미노 (하늘색)
	0 0 0 0	0 0 7 0	0 0 0 0	0 7 0 0
	7 7 7 7	0 0 7 0	0 0 0 0	0 7 0 0
	0 0 0 0	0 0 7 0	7 7 7 7	0 7 0 0
	0 0 0 0	0 0 7 0	0 0 0 0	0 7 0 0

 3. 블록의 좌표
  3.1. 블록의 좌표는 블록의 중심 좌표를 R, C라고 두면 (R-1 + 블록배열의 row값 + boardRow, C-1 + 블록배열의 column값 + boardColumn)으로 한다.
     -> 이때 나오는 boardRow, boardColumn은 게임 보드판의 기본좌표이다. 
         즉, 점수나 hold등의 이유로 보드판이 좌측 혹은 하단으로 밀릴 경우 보드판의 위치 값을 더해야 보드위에 블록이 제어된다.
         예를 들어, 게임 보드판의 좌측상단이 (3,5)에 위치한 경우 boardRow : 3, boardColumn은 5이다.
 
<블록 생성 및 하락>
1. 블록생성
 1.1. 현재 활성화 된 블록이 없을 경우 즉, 현재 플레이어 조작중인 블록이 없을 경우 보드 중앙 상단에 무작위 블록이 생성된다. (7bag 추후 고민)
 1.2. 블록의 생성 위치는 블록의 블록의 중앙 (즉, 3x3 배열의 [1][1])이 상하로 22번째 칸, 왼쪽에서 5번째칸([1][5])이 오게 생성된다.
      (단, I미노 블록은 왼쪽에서 4, 5, 6, 7번째에 형성된다.) (실제 게임에서 보이는 보드는 10*20이지만 프로그램 안에선 더 크게 잡는다.)
 
2.블록 낙하
 2.1. 블록이 생성되면 블록의 좌표를 배열에 따로 저장한다.
 2.2. 일정 시간이 지나면 저장된 블록의 좌표들을 +1 시킨다.
  2.2.1. 일정 시간은 시간함수를 이용한다.
 2.3. 단, 저장된 블록 좌표 바로 밑이 0이 아닐 경우, 낙하는 종료되고 새로운 블록을 형성한다.
 
<키보드 입력을 통한 회전 제어>
1. 키보드 입력
 1.1. 프로그램을 while문으로 계속 돌려 게임이 계속 진행되게 함과 동시에 kbhit()함수가 1이 될때 conio.h에 있는 getch를 이용하여 입력을 받는다.
2. 키셋팅
 2.1. <, > : 현재 블록을 좌우로 움직이기
 2.2. spacebar : 하드드롭 (바로 떨어트리기)
 2.3. z, ctrl : 반시계 (왼쪽 회전)
 2.4. x, ↑ : 시계 (오른쪽 회전)
 2.5.↓ : 소프트드롭 (아래로 한칸)
3. 회전 제어
 3.1. 회전과 관련된 키 입력을 받았을 때, 실행하게 된다.
 3.2. 회전을 하면 회전 인덱스 값을 변화시켜서 블록들의 좌표가 다시 업데이트 되도록 한다. 
      이 때 z회전은 인덱스가 감소하는 방향, x회전은 인덱스가 증가하는 방향으로 한다.
 3.3. 회전을 하기 전에, 미리 해당좌표에 블록 혹은 벽이 있는지 확인해야 한다.
 
<실시간 화면 출력>
1. 기본 화면
2. 화면의 변화
 2.1. 화면의 변화가 일어날 때 마다 gotoxy를 통해 커서를 움직인 후 변화된 문자를 출력하여 화면이 변하도록 한다.

<보드판 관리>


[세부 함수 내용]
-메인함수-
1.settingBoard()를 실행한다.
2.while(1)을 통해 다음을 반복한다.
 2.1. playing = updateGame()을 실행한다.
 2.2. playing = 0인 경우 반복을 종료한다.

-int updateGame()-
1. createBlock()를 실행한다.
last. return 0;

-void settingBoard-
1. board[0, 21][0~11] / board[0~21][0, 11]의 값을 -1로 설정한다.
2. board[0~21][0~11]까지 printBoard(board[row][column])을 통해 출력한다.
3. settingBlock()

-void printBoard(int blockCode, int x, int y)-
1.사각형의 크기가 2*1사이즈이므로 x*=2를 한다.
2.goto_xy(x, y)
3. blockCode 값에 따라 다음과 같이 출력한다.
 1.1. -1인 경우 □ 출력
 1.2. 0인 경우 "  " 출력 (빈칸 2칸)
 1.3. 나머지 경우 ■ 출력
 
-void goto_xy(int x, int y)-
1. HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE) 선언
2. COORD pos 선언(커서 위치)
3. pos.X = x / pos.Y = y (커서 위치 설정)
4. SetConsoleCursorPosition(handle, pos) (커서 위치 지정)

-void createBlock()-
0. blockExistence가 1인 경우 return 한다.
1. blockCode를 1~7사이의 무작위 정수로 설정한다.
2. blockCode에 따라 board값을 수정한다.
 2.1. board[0][4]~board[3][7]까지 수정해준다.
 2.2. 수정할 때마다 해당 블록값이 0이 아닌 경우 printBoard(blockCode, x, y)를 통해 출력 또한 수정해준다.

-void settingBlock()-
모든 미노의 블록 모양을 설정한다. (2번 항목 참고)


